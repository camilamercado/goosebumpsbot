{"google":"","tagline":"A make your own adventure TwitterBot powered by Node js","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"# @GiveGoosebumps \r\n\r\nA Bot that uses Twitters API to let users recreate R.L Stine's \"Give Yourself Goosebumps\" series via Tweet.\r\n\r\nBy Tweeting @GiveGoosebumps, any twitter user can trigger an automatic response from the Bot prompting them to \"Just tweet me hello and the game will begin!\"\r\n\r\nOnce the user tweets (@GiveGoosebumps hello) The narrative initiates and they will receive the first part of the story:\r\n\r\n``\r\n@User http://camilamercado.com/GBot/pp/001.htm 1355579704  To continue tweet back  yoyo or cellar\r\n``\r\nEach tweet contains a URL address where the user can read segments from the original Goose Bumps book to inform their next decision and continue the game:\r\n\r\n``\r\n@GiveGoosebumps yoyo\r\n``\r\nFrom here the narrative takes as many twists and turns as the GooseBumps book provides until some END is met, good or bad. At this point @GiveGoosebumps will respond:\r\n\r\n``\r\n@User http://camilamercado.com/GBot/pp/101.htm 1355579735  To continue tweet back  startover\r\n``\r\n...\r\n\r\n## Development\r\n\r\nIn order to develop the TwitterBot into its final stages many steps had to occur\r\n\r\n###Step One\r\n\r\nMapping out the Narrative. In order to get an idea for the structure of the text, testing was done on\r\n\r\nhttp://arborjs.org/halfviz/#/house-of-danger\r\n\r\nA site the convinientely enough was built to make interactive paths from data. Many examples of similar 'Make your own Adventure' type books had also been mapped out on the site. Here is an example of how the information was then organized:\r\n\r\n```\r\nDecision 1 Pg.3 {color:red, label:Decision 1}\r\n\r\nOption 1A Pg.16 {color:blue, label: Yoyo}\r\nOption 1B Pg.101 {color:blue, label: Cellar}\r\n\r\nDecision 1 Pg.3 -> Option 1A Pg.16\r\nDecision 1 Pg.3 ->Option 1B Pg.101\r\n\r\nOption 1A Pg.16 ->Decision 2 Pg.82\r\nOption 1B Pg.101 ->GAME OVER`1. \r\n```\r\n\r\nFrom this model, each decision gets accompanied by the page on which it occurs, a label that corresponds to the narrative, and the direction in which it continues. Once all of the decisions were painstakingly mapped out, the final product came like this:\r\n\r\n![map](MAP.jpg)\r\n\r\n###Step Two \r\n\r\nOnce all of the information had been taken down, it was time to reformat it in order to make a document the Bot could parse through, and progress the narrative. \r\n\r\n```\r\npage_0: {\r\n\t\turl: 'http://camilamercado.com/GBot/pp/001.htm',\r\n\t\topts: \"Hello\",\r\n\t\tdecisions:[\r\n\t\t\t{\r\n\t\t\t\tpage:1,\r\n\t\t\t\tname:'Hello'\r\n\t\t\t}\r\n\t\t]\r\n\t},\r\n\r\n\r\n\tpage_1: {\r\n\t\turl: 'http://camilamercado.com/GBot/pp/001.htm',\r\n\t\topts: \"yoyo or cellar\",\r\n\t\tdecisions:[\r\n\t\t\t{\r\n\t\t\t\tpage:16,\r\n\t\t\t\tname:'YoYo'\r\n\t\t\t}, \r\n\t\t\t{\r\n\t\t\t\tpage:101,\r\n\t\t\t\tname:'Cellar'\r\n\t\t\t}\r\n\t\t]\r\n\t},\r\n```\r\n\r\nThe final format assigns page_#'s to the array, in order to catalogue each URL and name that corresponds to each decision so that the Bot can jump from one decision to the next, providing the story text in the URL. \r\n\r\n###Step Three\r\n\r\nNow that the Narrative had been mapped, it was time to start putting together the Bot. After much research, the decision was made to have the Bot run on Node.js because of its Real-Time capabilities, and a breadth of documentation of other projects of a similar nature.\r\n At this point I came across a similar Twitter Bot named @Synomat whose purpose was to automatically tweet synonyms to other users. \r\n\r\nThe creator of the Bot, Tom Boutell made a blog \"Justjs\" helping to explain his process and teach js. \r\n\r\nhttps://github.com/boutell/justjs/tree/master/examples/synomat-1\r\nhttp://justjs.com/posts/synomat-a-twitter-thesaurus-powered-by-node-js\r\n\r\nProvided on the blog were the Github repositories, which where then forked over to create GooseBumpsBot.\r\nIn order to run node, it must be downloaded from the internet. Once node was successfully installed, a \r\n\r\nnpm install\r\n\r\ncommand was run from inside the justjs directory, in order to access the rest of the required repo's and documents.Starting from the top, Node documents give a directory of other docs needed to run the program:\r\n\r\n```\r\nvar _ = require('underscore');\r\nvar options = require('./options.js');\r\nvar ntwitter = require('ntwitter');\r\nvar fs = require('fs');\r\n```\r\n\r\n\r\nNow working with Node.js it was time to register @GiveGoosebumps with the Twitter Developer system and get the Oauth keys from (options.js) registered to the Bot in order to fill out options.js- a document that would be required to run the bot:\r\n\r\n```\r\nmodule.exports = {\r\n  twitter: {\r\n    username: 'synomat',\r\n    consumer_key: 'xxxx',\r\n    consumer_secret: 'xxxx',\r\n    access_token_key: 'xxxx',\r\n    access_token_secret: 'xxxx'\r\n  }\r\n};\r\n```\r\n\r\n\r\n###Step Four\r\n\r\nOnce the keys were filled out it was time to re-write the code to fit @GoosebumpsBot. Starting by requiring pages.js- the external document containing the story map. var current_page was set up to monitor the progression of the story as set up in the pages.js \r\n\r\n```\r\nvar _ = require('underscore');\r\nvar options = require('./options.js');\r\nvar ntwitter = require('ntwitter');\r\nvar fs = require('fs');\r\nvar pages = require('./pages.js'); \r\nvar tweeter = new ntwitter(options.twitter);\r\nvar http = require('http')\r\n\r\nvar me = options.twitter.username;\r\n\r\nvar currentPage = 'page_0';\r\n```\r\n\r\nFrom the Bot Function that was originally provided in the Justjs github, little was changed in its functionality except adding the current_page variable to move the tweets forward. Once The server identifies the credentials provided from options.js, the bot is ready to start listening for tweets. \r\n\r\n```\r\nfunction bot() {\r\n  tweeter.verifyCredentials(function (err, data) {\r\n    if (err) {\r\n      console.log(\"Credentials bad. Bummer. Go check that in dev.twitter.com.\");\r\n    }\r\n    console.log(\"Verified credentials\");\r\n  })\r\n  .stream('user', { track: options.twitter.username }, function(stream) {\r\n  // .stream('statuses/sample', function(stream) {\r\n    console.log(\"Listening to tweets\");\r\n    stream.on('data', function (data) {\r\n\r\n      if (!data.user)\r\n      {\r\n        // Not a tweet. For example I've received a list of friend ids\r\n        // here for some reason\r\n        return;\r\n      }\r\n\r\n   var them = data.user.screen_name;\r\n```\r\n\r\nAt this point the bot will begin to read through the tweet trying to find out if the content of the tweet (word), is equal to (decision.name) as provided in pages.js. If it is a match or (true) it will add the value of currentPage with decision.page and the story jumps ahead.\r\n\r\n\r\n\r\n```\r\nif (data.in_reply_to_screen_name.toLowerCase() === me.toLowerCase()) {\r\n        var result = data.text.match(/ (\\w+)\\s*$/);\r\n\r\n        if (result) {\r\n          var word = result[1].toLowerCase(),\r\n            isMatch=false;\r\n        console.log(pages[currentPage]);\r\n          _.each(pages[currentPage].decisions, function(decision, i){\r\n            console.log(decision);\r\n            if(word === decision.name.toLowerCase()){\r\n              isMatch=true;\r\n              currentPage = 'page_' + decision.page;\r\n            }\r\n\r\n          });\r\n  });\r\n          console.log('ok');\r\n          console.log(isMatch);\r\n```\r\n\r\nFrom here a lot of editing had to occur, to replace the thesaurus sourcing code of @Synomat, with the code needed to make @GiveGoosebumps.\r\n\r\n\r\n```\r\nvar currentTime = Math.round(+new Date()/1000);\r\n          \r\n          if(isMatch) {\r\n              // match\r\n              var replyText = pages[currentPage].url + ' ' + currentTime + ' ' + \" To continue tweet back  \" + pages[currentPage].opts,\r\n                \r\n                nextOpts = '';\r\n                \r\n                console.log(replyText);\r\n\r\n              _.each(pages[currentPage].content, function(decision, i){\r\n\r\n                if(i>0) {\r\n                  nextOpts += \" or\";\r\n                }\r\n\r\n                nextOpts =  nextOpts + ' ' + decision.name;\r\n              });\r\n\r\n              replyText += nextOpts;\r\n\r\n              console.log(replyText);\r\n              reply(replyText);\r\n```\r\n\r\nIn order to get around Twitters rules on spambots, a simple variable is made called currentTime, which gets called by the variable replyText every time the function is run and adds a different timestamp to every tweet run by the variable replyText. The body of reply text contains URL corresponding to the currentPage, the currentTime stamp, and a string that sources the new decision choices in the tweet text output. \r\n\r\n```\r\n} else {\r\n            \r\n          }\r\n\r\n        } else {\r\n          reply(\"Just tweet me hello and the game will begin!\");\r\n        }\r\n      }\r\n      function reply(msg)\r\n      {\r\n        tweeter.updateStatus(\"@\" + them + \" \" + msg, function(err, data)\r\n        {\r\n          if (err)\r\n          {\r\n            console.log(err);\r\n            // Not a big deal if a tweet fails. We could log something interesting though.\r\n          }\r\n        });\r\n      }\r\n    });\r\n```\r\n\r\nIn this code tweeter.updateStatus is run to output the message. @them becomes the initiating users twitter handle, and msg is the content of replyText. \r\n\r\n  \r\n``` \r\nstream.on('end', function (response) {\r\n      // Handle a disconnection\r\n      console.log('end event, listening again');\r\n      setTimeout(1000, listen);\r\n    });\r\n    stream.on('destroy', function (response) {\r\n      // Handle a 'silent' disconnection from Twitter, no end/error event fired\r\n      console.log('destroy event, listening again');\r\n      setTimeout(1000, listen);\r\n    });\r\n  });\r\n}\r\nvar port = process.env.PORT || 8080;\r\n\r\nhttp.createServer(function(req, res) {\r\n  req.addListener('end', function() {\r\n           res.end();\r\n   console.log('%s - %s', req.url, res.message);\r\n\r\n  });\r\n\r\n}).listen(port);\r\n```\r\n\r\nThe rest of the Document is set up to direct Node to the correct port to listen on and execute activity.\r\n\r\n###Step Five\r\n\r\nNow that the code was done, it was time to run the program through Terminal, directly through the computers server. To do this, the command was done to cd into the correct depository, and then run node.\r\n\r\nnode server.js\r\n\r\nAt this point the bot should console.log:\r\n\r\nListening to tweets\r\nVerified credentials\r\n\r\nThis means everything has worked up to this point, and the bot is ready to listen for tweets. When they come in the get logged as:\r\n\r\n{ url: 'http://camilamercado.com/GBot/pp/001.htm',\r\n  opts: 'Hello',\r\n  decisions: [ { page: 1, name: 'Hello' } ] }\r\n{ page: 1, name: 'Hello' }\r\nok\r\ntrue\r\nhttp://camilamercado.com/GBot/pp/001.htm 1355579704  To continue tweet back  yoyo or cellar\r\n\r\nLooks like everything has worked, now its time to check if the message was posted by @GiveGoosebumps on Twitter.\r\n\r\n![tweet](tweet.jpg)\r\n\r\nIt worked! Try it out @GiveGoosebumps\r\n\r\nShout out to \r\nErin Sparling\r\nJoe Kendall\r\n\r\nand of course\r\n\r\nR.L STINE\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","name":"GooseBumpsBot"}